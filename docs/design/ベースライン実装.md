# CMI Detect Behavior コンペティション ベースライン実装詳細手順

## 🎯 実装ゴール
- **Week 1終了時**: tsfresh + LightGBMでLB 0.50台
- **Week 2終了時**: 1D CNN導入でLB 0.57-0.60
- **Week 3終了時**: マルチモーダル統合でLB 0.62+（銅メダル圏）

## 📝 Week 1: 基盤構築（Day 1-7）

### Day 1-2: データ理解とEDA

#### 1. データ構造の把握
- [ ] train.csv, test.csv, sample_submission.csvの確認
- [ ] データサイズ、メモリ使用量の確認
- [ ] 各センサーチャンネルの意味理解
  - IMU（加速度・ジャイロ）: 身体動作検出
  - ToF: 手と顔の距離測定
  - Thermopile: 温度分布（顔接触検出）

#### 2. 基本統計量の確認
- [ ] センサーごとの値域、分布確認
- [ ] 欠損値パターンの分析（特にToF/温度センサー）
- [ ] 参加者ごとのデータ量確認
- [ ] 行動ラベルの分布（クラス不均衡度）

#### 3. 時系列可視化
- [ ] 各行動クラスのセンサー波形パターン確認
- [ ] 50Hzサンプリングの妥当性確認
- [ ] ノイズレベルの評価

### Day 3-4: 前処理パイプライン構築

#### 1. データクリーニング
- [ ] 異常値検出・処理方針決定
- [ ] 欠損値処理戦略
  - IMU: 線形補間
  - ToF/温度: 0埋めまたはforward fill
- [ ] タイムスタンプの連続性確認

#### 2. 正規化処理
- [ ] IMUデータのZ-score正規化実装
- [ ] 参加者単位での正規化 vs 全体正規化の検討
- [ ] センサーごとの正規化戦略決定

#### 3. セグメンテーション
- [ ] 固定窓（例: 2秒 = 100サンプル）での分割
- [ ] オーバーラップ設定（50%推奨）
- [ ] ラベル割り当て方針（多数決 or 中央値）

### Day 5-6: 特徴量エンジニアリング

#### 1. tsfresh導入
- [ ] tsfreshインストールと基本設定
- [ ] ComprehensiveFCParametersでの特徴量抽出
- [ ] 計算時間とメモリ使用量の確認

#### 2. 基本統計特徴量
- [ ] 時間窓内での統計量（平均、標準偏差、最大最小）
- [ ] センサー間の相関特徴量
- [ ] 変化率、ジャーク（加速度の微分）

#### 3. 周波数領域特徴量
- [ ] FFTによるスペクトル特徴
- [ ] パワースペクトル密度
- [ ] 主要周波数成分の抽出

### Day 7: ベースラインモデル構築

#### 1. GroupKFold実装
- [ ] participant_idによるグループ分割
- [ ] 5-fold設定でのデータリーク確認
- [ ] 各foldのクラス分布確認

#### 2. LightGBMベースライン
- [ ] 基本パラメータ設定
- [ ] Binary/Multiclassの個別モデル構築
- [ ] 評価指標実装（F1スコア計算）

#### 3. 初回提出
- [ ] 予測結果の生成
- [ ] submission.csv作成
- [ ] Kaggle提出とスコア確認

## 📊 Week 2: モデル改善（Day 8-14）

### Day 8-9: 1D CNN実装

#### 1. データ準備
- [ ] 3D配列形式への変換 (samples, timesteps, channels)
- [ ] 訓練/検証データジェネレーター作成
- [ ] メモリ効率的なバッチ処理

#### 2. InceptionTimeアーキテクチャ
- [ ] Inception moduleの実装
- [ ] 残差接続の追加
- [ ] マルチスケール畳み込み

#### 3. 学習設定
- [ ] 損失関数の選択（focal loss検討）
- [ ] 学習率スケジューラー
- [ ] Early stopping設定

### Day 10-11: データ拡張

#### 1. 時系列拡張手法
- [ ] 時間軸シフト（±0.5秒）
- [ ] ノイズ注入（Gaussian noise）
- [ ] 速度変化（1.1x, 0.9x）

#### 2. センサー固有の拡張
- [ ] IMU: 回転変換（左右の手の違い吸収）
- [ ] ToF: スケーリング（距離の個人差）
- [ ] 温度: オフセット追加

### Day 12-13: ハイブリッド予測

#### 1. 2段階予測戦略
- [ ] Stage 1: Binary分類（行動あり/なし）
- [ ] Stage 2: 行動ありの場合のMulticlass分類
- [ ] 閾値最適化

#### 2. 特徴量の使い分け
- [ ] Binary向け: 全体的な動きの有無
- [ ] Multiclass向け: 詳細な動作パターン

### Day 14: 中間評価

#### 1. エラー分析
- [ ] 混同行列の詳細分析
- [ ] 誤分類パターンの特定
- [ ] 参加者別の性能評価

#### 2. 改善点の特定
- [ ] 特定の行動クラスの精度向上策
- [ ] 特徴量の重要度分析
- [ ] 過学習の確認

## 🚀 Week 3: 最終調整（Day 15-21）

### Day 15-16: マルチモーダル統合

#### 1. センサー別ブランチ
- [ ] IMUブランチ（動作検出特化）
- [ ] ToFブランチ（距離パターン）
- [ ] 温度ブランチ（接触検出）

#### 2. 融合戦略
- [ ] 早期融合 vs 後期融合の比較
- [ ] アテンション機構の導入
- [ ] ブランチ重み付け学習

### Day 17-18: アンサンブル構築

#### 1. モデル多様性
- [ ] tsfresh + LightGBM
- [ ] 1D CNN（複数設定）
- [ ] XGBoost/CatBoost追加

#### 2. アンサンブル手法
- [ ] 単純平均
- [ ] 加重平均（CVスコアベース）
- [ ] スタッキング検討

### Day 19-20: 最終最適化

#### 1. ハイパーパラメータ調整
- [ ] Optunaによる自動最適化
- [ ] 学習率、正則化パラメータ
- [ ] アンサンブル重み

#### 2. TTA（Test Time Augmentation）
- [ ] 時間シフトTTA
- [ ] 複数予測の平均化
- [ ] 信頼度による重み付け

### Day 21: 最終提出準備

#### 1. コードクリーンアップ
- [ ] 不要なコードの削除
- [ ] 実行時間の最適化
- [ ] 再現性の確認

#### 2. ドキュメント作成
- [ ] 実装内容のまとめ
- [ ] 各手法の効果測定結果
- [ ] 今後の改善案

## 📈 期待されるスコア推移

| Week | 手法 | 期待CVスコア | 期待LBスコア |
|------|------|------------|------------|
| 1 | tsfresh + LightGBM | 0.48-0.52 | 0.47-0.51 |
| 2 | + 1D CNN | 0.55-0.58 | 0.54-0.57 |
| 2 | + データ拡張 | 0.57-0.60 | 0.56-0.59 |
| 3 | + マルチモーダル | 0.60-0.63 | 0.59-0.62 |
| 3 | + アンサンブル | 0.62-0.65 | 0.61-0.64 |

## ⚠️ 注意事項

### データリーク防止
- GroupKFoldを必ず使用（participant_id単位）
- 時系列の連続性を考慮した分割
- テストデータの参加者IDを訓練で使用しない

### 計算リソース管理
- tsfresh実行時のメモリ使用量監視
- GPUメモリに合わせたバッチサイズ調整
- 並列処理の活用（可能な箇所）

### 評価指標の理解
- Binary F1とMacro F1の個別モニタリング
- どちらがボトルネックかを常に確認
- クラス不均衡への対処

## 🎯 成功の鍵

1. **着実な積み上げ**: 各週の目標を確実に達成
2. **エラー分析**: 誤分類パターンの深掘り
3. **ドメイン知識**: BFRB行動の特徴理解
4. **実験管理**: 全ての試行を記録・比較

この手順に従って実装を進めることで、銅メダル圏（LB 0.60+）の達成が可能です。